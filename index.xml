<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>辉辉的小窝</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on 辉辉的小窝</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 10 Jan 2020 12:20:26 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;
&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>为什么说DOM操作慢</title>
      <link>http://localhost:1313/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4dom%E6%93%8D%E4%BD%9C%E6%85%A2/</link>
      <pubDate>Fri, 10 Jan 2020 12:20:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4dom%E6%93%8D%E4%BD%9C%E6%85%A2/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/bg2.jpg&#34; alt=&#34;背景&#34;&gt;&lt;/p&gt;
&lt;p&gt;在学前端的过程中，经常会听说DOM操作慢，要尽量少去操作DOM，本文就浅析一下DOM操作慢的原因&lt;/p&gt;
&lt;p&gt;我们知道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JS引擎不能操作页面，只能操作JS&lt;/li&gt;
&lt;li&gt;渲染引擎不能操作JS，只能操作页面&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;documentbodyappendchilddiv1js&#34;&gt;那document.body.appendChild(&amp;lsquo;div1&amp;rsquo;)这句JS是如何改变页面的呢？&lt;/h3&gt;
&lt;p&gt;我们先来完善一下这句JS语句的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let div1 = document.createElement(&#39;div1&#39;)
div1.innerTEXT = &#39;h1&#39;
document.body.append(div1)
//...省略n行代码
div.innerTEXT = `I&#39;m Jacky`
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码的运行过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 div1 放入页面之前:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对 div1 所有的操作都属于JS线程内的操作&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把 div1 放入页面中：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器会发现JS的意图&lt;/strong&gt;
&lt;strong&gt;就会通知渲染线程在页面中渲染 div1 对应的元素&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把 div1 放入页面之后&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你对 div1 的操作都&lt;a href=&#34;&#34;&gt;有可能&lt;/a&gt;触发重新渲染&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注： 有可能代表，可能触发也可能不触发&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;用图表示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E8%B7%A8%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C.png&#34; alt=&#34;跨线程&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，DOM对象本身也是一个js对象，所以严格来说，并不是操作这个对象慢，而是说操作了这个对象后，需要经过跨流程通信和渲染线程触发的重新渲染，导致DOM操作慢。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;div1innertext--im-jacky-&#34;&gt;div1.innerTEXT = &lt;code&gt;I&#39;m Jacky&lt;/code&gt; 操作了什么？&lt;/h3&gt;
&lt;p&gt;上图的最后一句语句，看似简单，但实际其全部含义是巨大的。可以粗略概述为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析`I&#39;m Jacky`为HTML文本&lt;/li&gt;
&lt;li&gt;向浏览器扩展程序寻求许可&lt;/li&gt;
&lt;li&gt;销毁现有的子节点div1&lt;/li&gt;
&lt;li&gt;创建子字节&lt;/li&gt;
&lt;li&gt;根据父子关系重新计算Layout&lt;/li&gt;
&lt;li&gt;重新Paint绘制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;JS引擎和和渲染引擎的模块化设计，使得它们可以独立优化，运行速度更快，但是这种设计带来的后果就是DOM操作会越来越慢。&lt;/strong&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS 函数的执行时机</title>
      <link>http://localhost:1313/post/js-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Sat, 04 Jan 2020 12:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/img1.jpg&#34; alt=&#34;img1&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;js&#34;&gt;关于JS任务执行&lt;/h3&gt;
&lt;p&gt;众所周知，JS是一门单线程语言。那就像我们去银行办理业务，而单线程意味着只有一个办理窗口，那么每个人都要等前一个人办理完成后，再去办理。同理JS也是一样，JS任务要一个一个按顺序执行。那么问题来了，如果前一个任务执行时间过长，后一个任务也要等着，这样必然增加了网页的加载时间。因此聪明的程序员将任务分成两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同步任务&lt;/p&gt;
&lt;p&gt;上一件事情没有完成，继续处理上一件事情，只有上一件事情完成了，才会做下一件事情 &amp;ndash;&amp;gt; JS中大部分都是同步编程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步任务&lt;/p&gt;
&lt;p&gt;规划要做一件事情，但是不是当前立马去执行这件事情，需要等一定的时间，这样的话，我们不会等着他执行，而是继续执行下面的操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;js-&#34;&gt;JS 函数的执行时机&lt;/h3&gt;
&lt;p&gt;函数执行的时机不同，运行结果也不同。下面我们按同步任务和异步任务两种情况，分别解释函数执行时机。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;同步&lt;/h2&gt;
&lt;h3 id=&#34;heading1&#34;&gt;举几个栗子&lt;/h3&gt;
&lt;p&gt;问：打印出多少?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = 1
function fn() {console.log(a)}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明变量a并赋值为1&lt;/li&gt;
&lt;li&gt;声明函数fn&lt;/li&gt;
&lt;li&gt;结束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：函数未执行，不打印结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = 1
function fn(){console.log(a)}
fn()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明变量a并赋值为1&lt;/li&gt;
&lt;li&gt;声明函数fn&lt;/li&gt;
&lt;li&gt;执行fn() //打印出a&lt;/li&gt;
&lt;li&gt;结束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：a的结果为1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = 1
function fn(){console.log(a)}
a = 2
fn()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明变量a并赋值为1&lt;/li&gt;
&lt;li&gt;声明函数fn&lt;/li&gt;
&lt;li&gt;将2赋值给a&lt;/li&gt;
&lt;li&gt;执行fn() //打印出a&lt;/li&gt;
&lt;li&gt;结束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：a的结果为2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = 1
function fn(){console.log(a)}
fn()
a = 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明变量a并赋值为1&lt;/li&gt;
&lt;li&gt;声明函数fn&lt;/li&gt;
&lt;li&gt;执行fn() //打印出a&lt;/li&gt;
&lt;li&gt;将2赋值为a&lt;/li&gt;
&lt;li&gt;结束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答：a的结果为1&lt;/p&gt;
&lt;p&gt;通过上面几个例子可以看出，在同步任务中，确定函数运行的结果，需要关注函数执行的时间前的代码。因为后面的代码还没执行，不会影响函数的运行结果。&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;异步&lt;/h2&gt;
&lt;p&gt;要说异步，就不得不用大名鼎鼎的setTimeout来举例子了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = 1
function fn(){
    setTimeout(()=&amp;gt;{
        console.log(a)
    },0)
}
fn() // 2
a = 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明变量a并赋值为1&lt;/li&gt;
&lt;li&gt;声明函数fn&lt;/li&gt;
&lt;li&gt;执行fn() &amp;ndash;&amp;gt; setTimeout()会过一会执行 &amp;ndash;&amp;gt;跳过setTimeout()&lt;/li&gt;
&lt;li&gt;将2赋值为a&lt;/li&gt;
&lt;li&gt;执行setTimeout() //打印出a&lt;/li&gt;
&lt;li&gt;结束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a的结果为2&lt;/p&gt;
&lt;h4 id=&#34;heading3&#34;&gt;再来看个经典面试题:&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;let i 
for( i = 0; i&amp;lt;6; i++){
    setTimeout(()=&amp;gt;{
        console.log(i)
    },0)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;问i的结果为？&lt;/p&gt;
&lt;p&gt;很简单，for循环总共执行6次。答案是0、1、2、3、4、5。&lt;/p&gt;
&lt;p&gt;完美！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;完美的错过了正确答案&lt;/p&gt;
&lt;p&gt;正确答案是6个6  //666666&lt;/p&gt;
&lt;p&gt;我们可以这样理解：&lt;/p&gt;
&lt;p&gt;for循环执行步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;i赋值为0&lt;/li&gt;
&lt;li&gt;判断i &amp;lt; 6 ?,满足进入第一循环&lt;/li&gt;
&lt;li&gt;setTimeout()会过一会执行&amp;ndash;&amp;gt;跳过setTimeout()继续执行&lt;/li&gt;
&lt;li&gt;执行i++，此时i的值为1&lt;/li&gt;
&lt;li&gt;判断i &amp;lt; 6 ?,满足进入第二循环&lt;/li&gt;
&lt;li&gt;setTimeout()会过一会执行&amp;ndash;&amp;gt;跳过setTimeout()继续执行&lt;/li&gt;
&lt;li&gt;执行i++，此时i的值为2&lt;/li&gt;
&lt;li&gt;省略&amp;hellip;&lt;/li&gt;
&lt;li&gt;执行i++，此时i的值为6&lt;/li&gt;
&lt;li&gt;判断i &amp;lt; 6 ?,不满足跳出循环&lt;/li&gt;
&lt;li&gt;执行第一次循环的setTimeout() //打印出a&lt;/li&gt;
&lt;li&gt;执行第二次循环的setTimeout() //打印出a&lt;/li&gt;
&lt;li&gt;执行第三次循环的setTimeout() //打印出a&lt;/li&gt;
&lt;li&gt;执行第四次循环的setTimeout() //打印出a&lt;/li&gt;
&lt;li&gt;执行第五次循环的setTimeout() //打印出a&lt;/li&gt;
&lt;li&gt;执行第六次循环的setTimeout() //打印出a&lt;/li&gt;
&lt;li&gt;结束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在可以看出，由于setTimeout()的执行时间为for语句执行后，所以每次打印出的结果都为6&lt;/p&gt;
&lt;h2 id=&#34;settimeout&#34;&gt;setTimeout()的&#39;过一会&#39;执行究竟是多久呢？&lt;/h2&gt;
&lt;p&gt;上文中不止一次提到&#39;过一会&#39;了,那么&#39;过一会&#39;究竟是多久呢？&lt;/p&gt;
&lt;p&gt;setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。也就是当同步任务的函数和语句执行完后，0秒或者立刻执行setTimeout(fn,0)。&lt;/p&gt;
&lt;h2 id=&#34;012345&#34;&gt;那我就是想要打印0、1、2、3、4、5呢？&lt;/h2&gt;
&lt;p&gt;如果对于for循环使用setTimeout()的循行结果不满意，我们就是要打印0、1、2、3、4、5呢？&lt;/p&gt;
&lt;p&gt;可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(let i = 0; i&amp;lt;6; i++){
    setTimeout(()=&amp;gt;{
        console.log(i)
    },0)
}
// 0 1 2 3 4 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解释： 因为let变量的作用域只能在当前函数中，所以每次for循环生成的都是一个新的i， setTimeout里输出的i就是这个新的i，这个i是不会变化的，所以输出的就是正常的。&lt;/p&gt;
&lt;p&gt;因为在for语句里用let声明变量是局部变量遵循块作用域，所以每次for循环执行时都会生成一个单独的作用域，也会生成一个新的i，相当于有6个 i。 此时，每次执行setTimeout()时都会打印出对应的i，打印结果就是0、1、2、3、4、5了。&lt;/p&gt;
&lt;h4 id=&#34;heading4&#34;&gt;我们还可以这样解决&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;闭包&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let i 
for(i = 0; i&amp;lt;6; i++){
  !function(j){
      setTimeout(()=&amp;gt;{
        console.log(j)
      },0)
  }(i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;利用 setTimeout 的第三个参数,将i传进去&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let i 
for(i = 0; i&amp;lt;6; i++){
  !function(j){
      setTimeout(()=&amp;gt;{
        console.log(j)
      },0)
  }(i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;利用 const 关键字&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;let i
for(i = 0; i&amp;lt;6; i++){
    const x = i
    setTimeout(()=&amp;gt;{
      console.log(x)
    })
}
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>JS 的 new 到底是干什么的？</title>
      <link>http://localhost:1313/post/js-%E7%9A%84-new-%E5%88%B0%E5%BA%95%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/</link>
      <pubDate>Thu, 02 Jan 2020 15:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js-%E7%9A%84-new-%E5%88%B0%E5%BA%95%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/</guid>
      
        <description>&lt;p&gt;大部分讲new的文章都会从面向对象的思路来讲，但是对于新手学习是，引入一个更复杂的概念，无疑是增加了学习了难度。&lt;/p&gt;
&lt;p&gt;本文将从[省代码]的角度讲解new&lt;/p&gt;
&lt;p&gt;举一个简单的栗子，有一条制造iPhoneX的流水线，生产出的iPhoneX在计算机里就是一堆属性，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/iPhoneX.png&#34; alt=&#34;iPhoneX&#34;&gt;&lt;/p&gt;
&lt;p&gt;写成代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let iPhoneX = {
    ID: 1,
    品牌: &#39;苹果&#39;,
    颜色: &#39;土豪金&#39;, //有多种配色
    屏幕: &#39;5.8英寸&#39;,
    开机: function(){/* 开机代码 */},
    死机: function(){/* 死机代码 */}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;1000iphonex&#34;&gt;制作1000台iPhoneX&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;let iPhoneXs = []
let iPhoneX 
for (let i = 0; i &amp;lt; 1000; i++) {
    iPhoneX = {
    ID: i,  //ID号不能重复
    品牌: &#39;苹果&#39;,
    颜色: &#39;土豪金&#39;,  //有多种配色
    屏幕: &#39;5.8英寸&#39;,
    开机: function(){/* 开机代码 */},
    死机: function(){/* 死机代码 */}
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;OK弄好了，so easy&lt;/p&gt;
&lt;h4 id=&#34;heading&#34;&gt;质疑&lt;/h4&gt;
&lt;p&gt;上面的代码存在一个问题：浪费了很多内存。&lt;/p&gt;
&lt;p&gt;开机代码和死机代码对于每台iPhoneX其实是一样的，只需要各自引用同一个函数就可以了，没必要重复创建到每一个iPhoneX对象里&lt;/p&gt;
&lt;p&gt;每台iPhoneX的品牌和屏幕尺寸也是相同的，同样没必要重复创建。&lt;/p&gt;
&lt;p&gt;只有 ID 和 颜色 需要重复创建。&lt;/p&gt;
&lt;h4 id=&#34;heading1&#34;&gt;改进&lt;/h4&gt;
&lt;p&gt;属性JS原型链的同学肯定知道，用原型链可以解决重复创建的问题，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let iPhoneXs = []
let iPhoneX 
let iPhoneX原型 = {
    品牌: &#39;苹果&#39;,
    屏幕: &#39;5.8英寸&#39;,
    开机: function(){/* 开机代码 */},
    死机: function(){/* 死机代码 */}
}
for (let i = 0; i &amp;lt; 1000; i++) {
    iPhoneX = {
    ID: i,  //ID号不能重复
    颜色: &#39;土豪金&#39; 
    }
    iPhoneX.__proto__ = iPhoneX原型
    iPhoneXs.push(iPhoneX)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;heading2&#34;&gt;还不够优雅？&lt;/h4&gt;
&lt;p&gt;有人指出制造iPhoneX的代码分散在两个地方不够优雅，于是我们用一个函数把这两个部分连接起来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let iPhoneXs = []
function iPhoneXCreate(ID) {                            //构造函数
    let iPhoneX = Object.create(iPhoneXCreate.iPhoneX原型)
    iPhoneX.ID = ID
    return iPhoneX
}
iPhoneXCreate.iPhoneX原型 = {
    品牌: &#39;苹果&#39;,
    屏幕: &#39;5.8英寸&#39;,
    开机: function(){/* 开机代码 */},
    死机: function(){/* 死机代码 */},X
    constructor: iPhoneXCreate
}
for (let i = 0; i &amp;lt; 1000; i++) {
    iPhoneXs[i] = iPhoneXCreate(i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;js-&#34;&gt;JS 之父的关怀&lt;/h4&gt;
&lt;p&gt;这一次我们用new来写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let iPhoneXs = []
function IPhoneX(ID) {
    this.ID = ID
}

IPhoneX.prototype.品牌 = &#39;苹果&#39;
IPhoneX.prototype.屏幕 = &#39;5.8英寸&#39;
IPhoneX.prototype.开机 = function(){/* 开机代码 */}
IPhoneX.prototype.死机 = function(){/* 死机代码 */}

for (let i = 0; i &amp;lt; 1000; i++) {
    iPhoneXs[i] = new IPhoneX(i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;完美，使用new省几行代码。（也就是所谓的语法糖）&lt;/p&gt;
&lt;p&gt;只要你在IPhoneX前面使用 new 关键字，那么可以少做四件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；&lt;/li&gt;
&lt;li&gt;不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；&lt;/li&gt;
&lt;li&gt;不用 return 临时对象，因为 new 会帮你做；&lt;/li&gt;
&lt;li&gt;不要给原型想名字了，因为 new 指定名字为 prototype。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文参考方应杭的文章&lt;a href=&#34;https://zhuanlan.zhihu.com/p/23987456&#34;&gt;JS 的 new 到底是干什么的？&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JavaScript对象基本用法</title>
      <link>http://localhost:1313/post/javascript%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Tue, 31 Dec 2019 15:15:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascript%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;对象是什么？&lt;/h2&gt;
&lt;p&gt;对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。&lt;/p&gt;
&lt;p&gt;什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。&lt;/p&gt;
&lt;h2 id=&#34;heading1&#34;&gt;声明对象的两种语法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;let obj = { &amp;lsquo;name&amp;rsquo; : &amp;lsquo;Jacky&amp;rsquo;, &amp;lsquo;age&amp;rsquo; : 18 }&lt;/li&gt;
&lt;li&gt;let obj = new Object{ &amp;lsquo;name&amp;rsquo; : &amp;lsquo;Jacky&amp;rsquo;, &amp;lsquo;age&amp;rsquo; : 18 }&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上两种方法都可以声明对象，第二种写法更规范，第一种是简化写法。&lt;/p&gt;
&lt;p&gt;细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键名是字符串，可以包含任何字符&lt;/li&gt;
&lt;li&gt;键名引号可以省略，但省略以后只能写标识符&lt;/li&gt;
&lt;li&gt;就算引号省略了，键名还是会转成字符串保存&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading2&#34;&gt;如何用变量做属性名&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;let a = &#39;name&#39;
let obj = { [a] : &#39;Jacky&#39; }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用中括号可以用变量做键名，如果是{ a : &amp;lsquo;jacky&amp;rsquo;},这样键名将会是&#39;a&amp;rsquo;。&lt;/p&gt;
&lt;h2 id=&#34;heading3&#34;&gt;如何删除对象的属性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;delete.obj.xxx 或者 delete.obj[&amp;lsquo;xxx&amp;rsquo;]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;delete命令删除对象的属性。删除成功后，就会返回true。&lt;/p&gt;
&lt;p&gt;要注意如果删除一个不存在的属性，也会返回true，只有在删除不能删除的属性时才会返回false。&lt;/p&gt;
&lt;h4 id=&#34;heading4&#34;&gt;如何查看删除是否成功&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;xxx&amp;rsquo; in obj === false&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lsquo;xxx&#39;不是obj的属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;xxx&amp;rsquo; in obj &amp;amp;&amp;amp; obj.xxx === undefined&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lsquo;xxx&#39;是obj的属性，值为undefined&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;如何查看对象的属性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Object.keys(obj)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看自身的所有属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;console.dir(obj)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看自身属性和共有属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obj.hasOwnProperty(&amp;lsquo;toString&amp;rsquo;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断一个属性是自身的还是共有的&lt;/p&gt;
&lt;h2 id=&#34;heading6&#34;&gt;如何修改或增加对象的属性&lt;/h2&gt;
&lt;h4 id=&#34;heading7&#34;&gt;修改对象属性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;obj[&amp;lsquo;name&amp;rsquo;] = &amp;lsquo;jacky&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改自身属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obj.name = &amp;lsquo;jacky&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改自身属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Object.assign(obj, {&amp;lsquo;age&amp;rsquo; : 18 &amp;hellip;})&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;批量修改自身属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Object.prototype[&amp;lsquo;toString&amp;rsquo;] = &amp;lsquo;xxx&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改共有属性，但不建议这样做&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;let obj = Object.create(common)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把obj的共有属性修改为common&lt;/p&gt;
&lt;h4 id=&#34;heading8&#34;&gt;增加对象属性&lt;/h4&gt;
&lt;p&gt;增加对象属性的方法同上，已有属性则改，没有属性则增&lt;/p&gt;
&lt;h2 id=&#34;objnameobjnameobjname&#34;&gt;区分obj[name]和obj[&amp;lsquo;name&amp;rsquo;]和obj.name&lt;/h2&gt;
&lt;p&gt;这三个表达式看起来都一样，让人傻傻分不清&lt;/p&gt;
&lt;p&gt;但实际上，obj[&amp;lsquo;name&amp;rsquo;] === obj.name ，name都是字符串&lt;/p&gt;
&lt;p&gt;obj[name],name则是变量&lt;/p&gt;
&lt;p&gt;不服请看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E5%AF%B9%E8%B1%A1-%E5%8C%BA%E5%88%86.png&#34; alt=&#34;区分&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JavaScript数据类型</title>
      <link>http://localhost:1313/post/javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 30 Dec 2019 15:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      
        <description>&lt;h3 id=&#34;javascript-&#34;&gt;JavaScript 数据类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4 id=&#34;number-&#34;&gt;number 数字&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;string-&#34;&gt;string 字符串&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;symbol-&#34;&gt;symbol 符号&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;bool-&#34;&gt;bool 布尔值&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;null-&#34;&gt;null 空&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;undefined-&#34;&gt;undefined 空&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;object-&#34;&gt;object 对象&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;口诀: 四基两空一对象&lt;/p&gt;
&lt;h3 id=&#34;number&#34;&gt;number&lt;/h3&gt;
&lt;p&gt;JS的数字采用64位浮点数储存，又称双精度浮点数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浮点就是可浮动的点，意思是小数点位置可以改动&lt;/li&gt;
&lt;li&gt;例如 123.456 可以表示位 1.23456e10^2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;64位浮点数的数据结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E6%B5%AE%E7%82%B9%E6%95%B0.png&#34; alt=&#34;浮点数&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指数位E：中间的 11 位存储指数（exponent），用来表示次方数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特殊值:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;正零和负零要区分，正零和负零值都为零&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正无穷大和负无穷大要区分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NaN (Not a Number) 也是数字类型，是一个未知数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;p&gt;JS的字符串采用阉割版的UTF-8，每个字符占两个字节&lt;/p&gt;
&lt;p&gt;写法可以是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号 &amp;ldquo;Hello&amp;rdquo;&lt;/li&gt;
&lt;li&gt;单引号 &amp;lsquo;Hello&amp;rsquo;&lt;/li&gt;
&lt;li&gt;反引号 `Hello`&lt;/li&gt;
&lt;li&gt;注意引号不属于字符串的一部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有时我们需要用到转义&lt;/p&gt;
&lt;p&gt;例如输入 &amp;lsquo;It&#39;s ok&amp;rsquo;，此时就会出现错误，JS引擎会认为&#39;it&#39;就结束了&lt;/p&gt;
&lt;p&gt;可以写成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;It&#39;s ok&amp;rsquo;  使用了转义&lt;/li&gt;
&lt;li&gt;&amp;ldquo;It&#39;s ok&amp;rdquo;&lt;/li&gt;
&lt;li&gt;`It&#39;s ok`&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多的转义写法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;quot; 表示 &amp;quot;&lt;/li&gt;
&lt;li&gt;&#39; 表示 &#39;&lt;/li&gt;
&lt;li&gt;\n 表示 换行&lt;/li&gt;
&lt;li&gt;\r 表示 回车&lt;/li&gt;
&lt;li&gt;\t 表示 Tab制表符&lt;/li&gt;
&lt;li&gt;\ 表示 \&lt;/li&gt;
&lt;li&gt;\uFFFF 表示对应的Unicode字符&lt;/li&gt;
&lt;li&gt;\xFF 表示前256个Unicode字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;symbol&#34;&gt;symbol&lt;/h3&gt;
&lt;p&gt;symbol使用情况很少，暂且不讲，以后用到再补充&lt;/p&gt;
&lt;h3 id=&#34;bool&#34;&gt;bool&lt;/h3&gt;
&lt;p&gt;布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。布尔值只有这两个值。&lt;/p&gt;
&lt;p&gt;下列运算符会返回布尔值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前置逻辑运算符： ! (Not)&lt;/li&gt;
&lt;li&gt;相等运算符：===，!==，==，!=&lt;/li&gt;
&lt;li&gt;比较运算符：&amp;gt;，&amp;gt;=，&amp;lt;，&amp;lt;=&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那问题来了如果表达式不返回布尔值，怎么判断真假呢？&lt;/p&gt;
&lt;p&gt;答:记住五个falsy值，falsy就是相当于false，但又不是false的值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;0&lt;/li&gt;
&lt;li&gt;NaN&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&amp;ldquo;或&amp;rsquo;&#39;（空字符串）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其余不返回布尔值的表达式都为真&lt;/p&gt;
&lt;h3 id=&#34;null--undefined&#34;&gt;null 和 undefined&lt;/h3&gt;
&lt;p&gt;null与undefined都可以表示“没有”，含义非常相似。本质上没有区别。&lt;/p&gt;
&lt;p&gt;不过要注意以下几个细节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个变量声明了，但没有赋值，那么默认值就是undefined，而不是null&lt;/li&gt;
&lt;li&gt;如果一个函数，没有写return，那么默认return undefined，而不是null&lt;/li&gt;
&lt;li&gt;前端程序员习惯上，把非对象的空值写为undefined，把对象的空值写为null，但只是习惯而已&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;object&#34;&gt;object&lt;/h3&gt;
&lt;p&gt;object的内容较多，会在下一个blog补充，欢迎查看。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JavaScript基本语法</title>
      <link>http://localhost:1313/post/javascript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 29 Dec 2019 15:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascript%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
      
        <description>&lt;h2 id=&#34;heading&#34;&gt;什么是表达式和语句？&lt;/h2&gt;
&lt;h3 id=&#34;heading1&#34;&gt;语句&lt;/h3&gt;
&lt;p&gt;JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。&lt;/p&gt;
&lt;p&gt;语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var a = 1 + 3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这条语句先用var命令，声明了变量a，然后将1 + 3的运算结果赋值给变量a。&lt;/p&gt;
&lt;h3 id=&#34;heading2&#34;&gt;表达式&lt;/h3&gt;
&lt;p&gt;1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。&lt;/p&gt;
&lt;p&gt;add(1,2)表达式的值为函数的返回值&lt;/p&gt;
&lt;p&gt;console.log表达式的值为函数本身&lt;/p&gt;
&lt;p&gt;console.log(3)表达式的值为函数的返回值，也就是undefined&lt;/p&gt;
&lt;h3 id=&#34;heading3&#34;&gt;两者的区别&lt;/h3&gt;
&lt;p&gt;语句和表达式的区别在于，语句是为了进行某种操作，一般情况下不需要返回值，而表达式都是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。&lt;/p&gt;
&lt;h3 id=&#34;heading4&#34;&gt;简单的判断方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;利用if语句判断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;if(xxx){},如果没有报错就说明xxx是表达式，因为if括号里面需要的是布尔值，只要是有这个值就是表达式&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/if%E5%88%A4%E6%96%AD.png&#34; alt=&#34;if&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用赋值变量来判断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为表达式得到的是一个值，所以表达式可以赋值给一个变量，而如果是语句的话就会报错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E5%88%A4%E6%96%AD.png&#34; alt=&#34;变量&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading5&#34;&gt;标识符的规则&lt;/h2&gt;
&lt;p&gt;标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以a和A是两个不同的标识符。&lt;/p&gt;
&lt;p&gt;简单说，标识符命名规则如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。注意不能使用数字&lt;/li&gt;
&lt;li&gt;第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字 0-9。&lt;/li&gt;
&lt;li&gt;中文也是合法的标识符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;if-else-&#34;&gt;if else 语句&lt;/h2&gt;
&lt;h3 id=&#34;heading6&#34;&gt;语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;if(布尔值){语句1} else{语句2}&lt;/li&gt;
&lt;li&gt;{}在语句只有一句的时候可以省略，不建议这样做&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading7&#34;&gt;举个栗子&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;if (m === 3) {
    console.log(&amp;quot;m等于3&amp;quot;)
    // 满足条件时，执行的语句
} 
else {
    console.log(&#39;m不等于3&#39;)
    // 不满足条件时，执行的语句
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码判断变量m是否等于3，如果等于就执行if代码块，否则执行else代码块。&lt;/p&gt;
&lt;h2 id=&#34;while-&#34;&gt;while 语句&lt;/h2&gt;
&lt;h3 id=&#34;heading8&#34;&gt;语法&lt;/h3&gt;
&lt;p&gt;while(表达式){循环体}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断表达式真假&lt;/li&gt;
&lt;li&gt;当表达式为真时，执行语句，在判断表达式真假&lt;/li&gt;
&lt;li&gt;当表达式为假时，执行后面的语句&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading9&#34;&gt;举个栗子&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var i = 0;

while (i &amp;lt; 10) {
  console.log(&#39;i 当前为：&#39; + i);
  i = i + 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码将循环10次，直到i等于10为止。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (true) {
  console.log(&#39;Hello, world&#39;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的例子是一个无限循环，因为循环条件总是为真。&lt;/p&gt;
&lt;h2 id=&#34;for-&#34;&gt;for 语句&lt;/h2&gt;
&lt;h3 id=&#34;heading10&#34;&gt;语法&lt;/h3&gt;
&lt;p&gt;for (语句1，表达式2，语句3){循环体}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先执行语句1&lt;/li&gt;
&lt;li&gt;然后判断语句2&lt;/li&gt;
&lt;li&gt;如果为真，执行循环体，然后执行语句3&lt;/li&gt;
&lt;li&gt;如果为假，跳出循环，执行后面的语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;for 是 while 的方便写法&lt;/p&gt;
&lt;h3 id=&#34;heading11&#34;&gt;举个栗子&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;if (let i = 1; i &amp;lt; 10; i++) {
    console.log(&#39;i 当前为：&#39; + i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码将循环10次，直到i等于10为止。&lt;/p&gt;
&lt;h2 id=&#34;break&#34;&gt;break&lt;/h2&gt;
&lt;h3 id=&#34;break1&#34;&gt;break语句用于跳出代码块或循环。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for (let i = 0; i &amp;lt; 5; i++) {
  console.log(i);
  if (i === 3)
    break;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码执行到i等于3，就会跳出循环。&lt;/p&gt;
&lt;h2 id=&#34;continue&#34;&gt;continue&lt;/h2&gt;
&lt;h3 id=&#34;continue1&#34;&gt;continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;for (let i = 0; i &amp;lt; 100; i++) {
    if (i % 2 === 0) {continue} ;
    console.log(&#39;i 当前为：&#39; + i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。&lt;/p&gt;
&lt;h3 id=&#34;breakcontinue&#34;&gt;如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。&lt;/h3&gt;
&lt;h2 id=&#34;label&#34;&gt;label&lt;/h2&gt;
&lt;p&gt;JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。&lt;/p&gt;
&lt;h3 id=&#34;heading12&#34;&gt;举些栗子&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;top:
  for (var i = 0; i &amp;lt; 3; i++){
    for (var j = 0; j &amp;lt; 3; j++){
      if (i === 1 &amp;amp;&amp;amp; j === 1) break top;
      console.log(&#39;i=&#39; + i + &#39;, j=&#39; + j);
    }
  }
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo: {
  console.log(1);
  break foo;
  console.log(&#39;本行不会输出&#39;);
}
console.log(2);
// 1
// 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码执行到break foo，就会跳出区块。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;top:
  for (var i = 0; i &amp;lt; 3; i++){
    for (var j = 0; j &amp;lt; 3; j++){
      if (i === 1 &amp;amp;&amp;amp; j === 1) continue top;
      console.log(&#39;i=&#39; + i + &#39;, j=&#39; + j);
    }
  }
// i=0, j=0
// i=0, j=1
// i=0, j=2
// i=1, j=0
// i=2, j=0
// i=2, j=1
// i=2, j=2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>从Brendan Eich的自述看JavaScript的诞生</title>
      <link>http://localhost:1313/post/%E4%BB%8Ebrendan-eich%E7%9A%84%E8%87%AA%E8%BF%B0%E7%9C%8Bjavascript%E7%9A%84%E8%AF%9E%E7%94%9F/</link>
      <pubDate>Wed, 25 Dec 2019 15:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E4%BB%8Ebrendan-eich%E7%9A%84%E8%87%AA%E8%BF%B0%E7%9C%8Bjavascript%E7%9A%84%E8%AF%9E%E7%94%9F/</guid>
      
        <description>&lt;h2 id=&#34;javascript&#34;&gt;JavaScript的诞生&lt;/h2&gt;
&lt;p&gt;从历史的角度，说明Javascript到底是如何设计出来的。只有了解这段历史，才能明白Javascript为什么是现在的样子。我依据的资料，主要是Brendan Eich的自述。&lt;/p&gt;
&lt;h3 id=&#34;1&#34;&gt;1&lt;/h3&gt;
&lt;p&gt;1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。&amp;hellip;&amp;hellip;网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/navigator.jpg&#34; alt=&#34;Navigator&#34;&gt;&lt;/p&gt;
&lt;p&gt;网页脚本语言到底是什么语言？网景公司当时有两个选择：一个是采用现有的语言，比如Perl、Python、Tcl、Scheme等等，允许它们直接嵌入网页；另一个是发明一种全新的语言。&lt;/p&gt;
&lt;p&gt;这两个选择各有利弊。第一个选择，有利于充分利用现有代码和程序员资源，推广起来比较容易；第二个选择，有利于开发出完全适用的语言，实现起来比较容易。到底采用哪一个选择，网景公司内部争执不下，管理层一时难以下定决心。&lt;/p&gt;
&lt;h3 id=&#34;2&#34;&gt;2&lt;/h3&gt;
&lt;p&gt;就在这时，发生了另外一件大事：1995年Sun公司将Oak语言改名为Java，正式向市场推出。&lt;/p&gt;
&lt;p&gt;Sun公司大肆宣传，许诺这种语言可以&amp;quot;一次编写，到处运行&amp;rdquo;（Write Once, Run Anywhere），它看上去很可能成为未来的主宰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/JAVA.png&#34; alt=&#34;JAVA&#34;&gt;&lt;/p&gt;
&lt;p&gt;网景公司动了心，决定与Sun公司结成联盟。它不仅允许Java程序以applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂，后来才不得不放弃。&lt;/p&gt;
&lt;p&gt;总之，当时的形势就是，网景公司的整个管理层，都是Java语言的信徒，Sun公司完全介入网页脚本语言的决策。因此，Javascript后来就是网景和Sun两家公司一起携手推向市场的，这种语言被命名为&amp;quot;Java+script&amp;quot;并不是偶然的。&lt;/p&gt;
&lt;h3 id=&#34;3&#34;&gt;3&lt;/h3&gt;
&lt;p&gt;此时，34岁的系统程序员Brendan Eich登场了。1995年4月，网景公司录用了他。&lt;/p&gt;
&lt;p&gt;Brendan Eich的主要方向和兴趣是函数式编程，网景公司招聘他的目的，是研究将Scheme语言作为网页脚本语言的可能性。Brendan Eich本人也是这样想的，以为进入新公司后，会主要与Scheme语言打交道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/Brendan.jpg&#34; alt=&#34;Brendan&#34;&gt;&lt;/p&gt;
&lt;p&gt;仅仅一个月之后，1995年5月，网景公司做出决策，未来的网页脚本语言必须&amp;quot;看上去与Java足够相似&amp;rdquo;，但是比Java简单，使得非专业的网页作者也能很快上手。这个决策实际上将Perl、Python、Tcl、Scheme等非面向对象编程的语言都排除在外了。&lt;/p&gt;
&lt;p&gt;Brendan Eich被指定为这种&amp;quot;简化版Java语言&amp;quot;的设计师。&lt;/p&gt;
&lt;h3 id=&#34;4&#34;&gt;4&lt;/h3&gt;
&lt;p&gt;但是，他对Java一点兴趣也没有。为了应付公司安排的任务，他只用10天时间就把Javascript设计出来了。&lt;/p&gt;
&lt;p&gt;由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。如果Brendan Eich预见到，未来这种语言会成为互联网第一大语言，全世界有几百万学习者，他会不会多花一点时间呢？&lt;/p&gt;
&lt;p&gt;总的来说，他的设计思路是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;借鉴C语言的基本语法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;借鉴Java语言的数据类型和内存管理；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;借鉴Scheme语言，将函数提升到&amp;quot;第一等公民&amp;rdquo;（first class）的地位；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;借鉴Self语言，使用基于原型（prototype）的继承机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，Javascript语言实际上是两种语言风格的混合产物&amp;mdash;-（简化的）函数式编程+（简化的）面向对象编程。这是由Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定的。&lt;/p&gt;
&lt;h3 id=&#34;5&#34;&gt;5&lt;/h3&gt;
&lt;p&gt;多年以后，Brendan Eich还是看不起Java。&lt;/p&gt;
&lt;p&gt;他说：&amp;ldquo;Java（对Javascript）的影响，主要是把数据分成基本类型（primitive）和对象类型（object）两种，比如字符串和字符串对象，以及引入了Y2K问题。这真是不幸啊。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;把基本数据类型包装成对象，这样做是否可取，这里暂且不论。Y2K问题则是直接与Java有关。根据设想，Date.getYear()返回的应该是年份的最后两位：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var date1 = new Date(1999,0,1);

var year1 = date1.getYear();

alert(year1); // 99
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是实际上，对于2000年，它返回的是100！&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var date2 = new Date(2000,0,1);

var year2 = date2.getYear();

alert(year2); // 100
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果用这个函数生成年份，某些网页可能出现&amp;quot;19100&amp;quot;这样的结果。这个问题完全来源于Java，因为Javascript的日期类直接采用了java.util.Date函数库。Brendan Eich显然很不满意这个结果，这导致后来不得不添加了一个返回四位数年份的Date.getFullYear()函数。&lt;/p&gt;
&lt;p&gt;如果不是公司的决策，Brendan Eich绝不可能把Java作为Javascript设计的原型。作为设计者，他一点也不喜欢自己的这个作品：&lt;/p&gt;
&lt;h3 id=&#34;javascriptcselfthe-part-that-is-good-is-not-original-and-the-part-that-is-original-is-not-good&#34;&gt;&amp;ldquo;与其说我爱Javascript，不如说我恨它。它是C语言和Self语言一夜情的产物。十八世纪英国文学家约翰逊博士说得好：&amp;lsquo;它的优秀之处并非原创，它的原创之处并不优秀。&#39;（the part that is good is not original, and the part that is original is not good.）&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;整理自阮一峰的网络日志&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS动画优化</title>
      <link>http://localhost:1313/post/css%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 19 Dec 2019 15:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96/</guid>
      
        <description>&lt;h1 id=&#34;heading&#34;&gt;浏览器渲染原理&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/randertree.png&#34; alt=&#34;渲染树&#34;&gt;
浏览器渲染经过以下步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据HTML构建HTML树。(DOM)&lt;/li&gt;
&lt;li&gt;根据CSS构建CSS树。(CSSOM)&lt;/li&gt;
&lt;li&gt;将两棵树合并成一颗渲染树。(rander tree)&lt;/li&gt;
&lt;li&gt;Layout布局(文档流、盒模型、计算大小和位置)。&lt;/li&gt;
&lt;li&gt;Paint绘制(把边框颜色、文字颜色、阴影等画出来)。&lt;/li&gt;
&lt;li&gt;Compose合成(根据层叠关系展示画面).&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;css&#34;&gt;如何优化CSS动画&lt;/h1&gt;
&lt;h3 id=&#34;heading1&#34;&gt;答案是:减少浏览器的渲染次数&lt;/h3&gt;
&lt;p&gt;三种的更新方式:
&lt;img src=&#34;http://localhost:1313/images/3ways.png&#34; alt=&#34;三种更新方式&#34;&gt;&lt;/p&gt;
&lt;p&gt;可见三种更新方式中,第一种更新方法需要重新渲染3次(包括layout,paint,compose),第二种需重新渲染2次,而第三种只需要重新渲染1次.&lt;/p&gt;
&lt;p&gt;不同的CSS属性有不同的更新方式,大家可以参考csstriggers.com(不需硬记),这个网站已经把所有属性都试过了.&lt;/p&gt;
&lt;p&gt;Tips: 参考网站中的Blink为谷歌浏览器内核,Gecko为火狐浏览器内核,WebKit为Safari浏览器内核,EdgeHTML为IE浏览器内核&lt;/p&gt;
&lt;p&gt;所以优化CSS动画性能的方法是尽量使用渲染次数少的CSS属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS优化:使用will-change或translate&lt;/li&gt;
&lt;li&gt;JS优化:使用requestAnimaitonFrame代替setTimeout或setlnterval&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS动画制作的两种做法</title>
      <link>http://localhost:1313/post/css%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%81%9A%E6%B3%95/</link>
      <pubDate>Wed, 18 Dec 2019 15:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E5%8A%A8%E7%94%BB%E5%88%B6%E4%BD%9C%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%81%9A%E6%B3%95/</guid>
      
        <description>&lt;h1 id=&#34;heading&#34;&gt;我们来做一颗跳动的心吧&lt;/h1&gt;
&lt;h2 id=&#34;heading1&#34;&gt;首先我们需要一颗心&lt;/h2&gt;
&lt;p&gt;百度搜索&amp;quot;心&amp;rdquo;&lt;img src=&#34;http://localhost:1313/images/heart.png&#34; alt=&#34;heart&#34;&gt;&lt;/p&gt;
&lt;p&gt;&amp;hellip;&amp;hellip;这个也太可怕了吧,不适合儿童观众,我们还是自己用CSS画一个吧.&lt;/p&gt;
&lt;p&gt;心怎么画?我们学的块级元素都是方形的,算加上border-radius也顶多只能画个 球&lt;/p&gt;
&lt;p&gt;好吧!发挥我们的想象力,我们可以把它分解成两圆一方
&lt;img src=&#34;http://localhost:1313/images/ugly.png&#34; alt=&#34;丑&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/code.png&#34; alt=&#34;code&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;transform&#34;&gt;用transform方法制作动画&lt;/h2&gt;
&lt;p&gt;我们需要做的动画让心放大-缩小-放大-缩小,以达到跳动的效果&lt;/p&gt;
&lt;p&gt;在原有代码中增加tranform的transition(动画过渡)和scale(缩放),代码如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/code1.png&#34; alt=&#34;code&#34;&gt;&lt;/p&gt;
&lt;p&gt;transform属性中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;transition: all 1s;&lt;/code&gt;动画播放时间1s&lt;/li&gt;
&lt;li&gt;&lt;code&gt;transform: scale(1.5);&lt;/code&gt;元素放大1.5倍&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;动画效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/demo.gif&#34; alt=&#34;demo&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;animation&#34;&gt;用animation方法制作动画&lt;/h2&gt;
&lt;p&gt;在原有代码中增加animation和@keyframes heart(窗口名称),代码如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/code2.png&#34; alt=&#34;code&#34;&gt;&lt;/p&gt;
&lt;p&gt;animation属性中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;animation:.5s heart infinite alternate-reverse;&lt;/code&gt;动画播放时间0.5s,目标窗口名称heart,infinite为无限播放,alternate-reverse为反向开始循环播放&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;@keyframes heart {
  0%{transform: scale(1);}
  100%{transform: scale(1.5);}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在0%时刻缩放比为1,在100%时刻缩放比1.5&lt;/p&gt;
&lt;p&gt;动画效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/demo1.gif&#34; alt=&#34;demo1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;animation1&#34;&gt;用animation方法制作多个时间点动画&lt;/h2&gt;
&lt;p&gt;多个时间点动画表示,在多个时刻进行不同的变化;&lt;/p&gt;
&lt;p&gt;在上一步的代码中修改@keyframes heart,代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@keyframes heart {
  0%{
    transform: scale(1);
  }
  50%{
    transform: scale(.5);
  }
  100%{
    transform: scale(1.5);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在0%时刻缩放比为1,在50%时刻缩放比0.5,在100%时刻缩放比1.5&lt;/p&gt;
&lt;p&gt;动画效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/demo2.gif&#34; alt=&#34;demo1&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading2&#34;&gt;总结:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;transform和animation都可以用于制作CSS动画,animation在制作多个时间点动画会更加方便.&lt;/li&gt;
&lt;li&gt;transform和animation还有很多用法,请在MDN中进行学习.&lt;/li&gt;
&lt;li&gt;虽CSS属性虽然简单,但是要用好靠的是想象力&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>浅析 URL</title>
      <link>http://localhost:1313/post/%E6%B5%85%E6%9E%90-url/</link>
      <pubDate>Sun, 15 Dec 2019 15:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E6%B5%85%E6%9E%90-url/</guid>
      
        <description>&lt;h2 id=&#34;url&#34;&gt;URL组成&lt;/h2&gt;
&lt;p&gt;URL，统一资源定位符，用于定位互联网上资源，俗称网址。&lt;/p&gt;
&lt;h3 id=&#34;url1&#34;&gt;URL的组成:&lt;/h3&gt;
&lt;h4 id=&#34;urlip&#34;&gt;URL=协议+域名或IP+端口号+路径+查询字符串+锚点&lt;/h4&gt;
&lt;h3 id=&#34;url2&#34;&gt;URL的写法:&lt;/h3&gt;
&lt;h4 id=&#34;schemehostdomainportpathfilename&#34;&gt;scheme://host.domain:port/path/filename&lt;/h4&gt;
&lt;h3 id=&#34;httpswwwzhihucomexplore&#34;&gt;举个&lt;a href=&#34;https://www.zhihu.com/explore&#34;&gt;栗子&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&#34;httpswwwzhihucomexplore1&#34;&gt;&lt;a href=&#34;https://www.zhihu.com/explore&#34;&gt;https://www.zhihu.com/explore&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在上面的网站中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;scheme - 定义因特网服务的类型。常见的协议有 http、https、ftp、file，其中最常见的类型是http，而 https 则是进行加密的网络传输。例子中使用的是https&lt;/li&gt;
&lt;li&gt;host - 定义域主机（http 的默认主机是 www）&lt;/li&gt;
&lt;li&gt;domain - 定义因特网域名，例子中就是zhihu.com&lt;/li&gt;
&lt;li&gt;port - 定义主机上的端口号（http的默认端口号是 80,https 默认是 443，FTP 默 21 端口）,&lt;/li&gt;
&lt;li&gt;例子中https的默认端口是443(已被省略)&lt;/li&gt;
&lt;li&gt;path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）,例子中的路径就是/explore&lt;/li&gt;
&lt;li&gt;filename - 定义文档/资源的名称&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ip&#34;&gt;IP&lt;/h2&gt;
&lt;p&gt;IP的全称为Internet Protocol(互联网协议),是设备的数字便签,用于互联网定位.常见的IP可分为IPv4。常见的IP地址可分为IPv4和IPv6两类,其中使用最广泛的是IPv4。&lt;/p&gt;
&lt;p&gt;IP可以分为内网IP和外网IP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外网IP由通讯公司提供,如国内的电信、移动等。外网用于外网之间的通信和定位&lt;/li&gt;
&lt;li&gt;内网IP由路由器分配,用于区分内网连接设备&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading&#34;&gt;域名&lt;/h2&gt;
&lt;p&gt;域名实际上是IP地址的代称,目的是为了方便记忆。例如39.156.69.79这个百度的IP地址,在浏览器输入就可以访问百度,但我相信没人会这样做,因为这样实在太难记了。但baidu.com就十分方便好记,www.baidu.com通过DNS就会返回39.156.69.79这个IP,浏览器就可以访问了。&lt;/p&gt;
&lt;p&gt;域名可以分为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶级域名,例如&amp;rdquo;.com&amp;rdquo;、&amp;quot;.net&amp;rdquo;、&amp;quot;.org&amp;rdquo;、&amp;quot;.edu&amp;rdquo;、&amp;quot;.info&amp;rdquo;&lt;/li&gt;
&lt;li&gt;二级域名,例如&amp;quot;xiedaima.com&amp;rdquo;&lt;/li&gt;
&lt;li&gt;父域名&lt;/li&gt;
&lt;li&gt;子域名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一图流总结:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/domain.png&#34; alt=&#34;domain&#34;&gt;&lt;/p&gt;
&lt;p&gt;推荐一个可以查询自己域名的网站:IP138.com&lt;/p&gt;
&lt;h2 id=&#34;dns&#34;&gt;DNS&lt;/h2&gt;
&lt;p&gt;DNS，全称 Domain Name System(service)，是一个域名系统。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。&lt;/p&gt;
&lt;p&gt;在bash,输入ping命令即可查询到域名对应的IP地址。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/ip.png&#34; alt=&#34;IP&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>负margin的理解</title>
      <link>http://localhost:1313/post/%E8%B4%9Fmargin%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Sun, 15 Dec 2019 15:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E8%B4%9Fmargin%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      
        <description>&lt;h2 id=&#34;margin&#34;&gt;margin的概述&lt;/h2&gt;
&lt;p&gt;margin属性为给定元素设置所有四个（上下左右）方向的外边距属性。这是四个外边距属性设置的简写。四个外边距属性设置分别是： margin-top， margin-right， margin-bottom 和 margin-left 。指定的外边距允许为负数。&lt;/p&gt;
&lt;h2 id=&#34;httpjsjirengucomligex1edithtmlcssoutput&#34;&gt;先上&lt;a href=&#34;http://js.jirengu.com/ligex/1/edit?html,css,output&#34;&gt;栗子&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;此次测试的方法是,通过设定margin-left的值从正值变为负值,来观察其对div大小和移动方向的改变&lt;/p&gt;
&lt;p&gt;测试代码:&lt;/p&gt;
&lt;h3 id=&#34;html&#34;&gt;HTML代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;负margin测试&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;test&amp;quot;&amp;gt;test-test-test&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;css&#34;&gt;CSS代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;*{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
.container{
  margin: 50px;
  border: 1px solid blue;
  
}
.test{
  margin: 20px;
  margin-left: 0px;
  border: 1px solid green;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试代码很简单,由简单入手，正所谓删繁就简三秋树，领异标新二月花&lt;/p&gt;
&lt;h3 id=&#34;-marginleft-0&#34;&gt;第一步 设定margin-left: 0;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/margin0.png&#34; alt=&#34;margin0&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示,margin-left赋值为0px,覆盖了它的初始值10px。图中蓝色是container的border,绿色是content的border,可以看出content此时宽度为554px&lt;/p&gt;
&lt;h3 id=&#34;-marginleft-30px&#34;&gt;第二步 设定margin-left: 30px;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/margin30.png&#34; alt=&#34;margin30&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示,可以看出content此时宽度为524px,对比上一步减少了30px,左边缘向右移动&lt;/p&gt;
&lt;h2 id=&#34;-marginleft-50px&#34;&gt;第三步 设定margin-left: 50px;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/margin50.png&#34; alt=&#34;marign50&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示,可以看出content此时宽度为504px,对比上一步减少了20px,左边缘向右移动&lt;/p&gt;
&lt;p&gt;此时不难看出,margin-left值增大时,test被向右挤压,宽度逐渐缩小&lt;/p&gt;
&lt;h2 id=&#34;-marginleft-20px&#34;&gt;第四步 设定margin-left: 20px;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/margin20.png&#34; alt=&#34;marign20&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示,可以看出content此时宽度为534px,对比上一步增加了30px,左边缘向右移动&lt;/p&gt;
&lt;p&gt;可以看出,当margin-left值减少时,test向左扩展,宽度逐渐增大&lt;/p&gt;
&lt;h3 id=&#34;-marginleft-20px1&#34;&gt;第五步 设定margin-left: -20px;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/margin-20.png&#34; alt=&#34;marign-20&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示,可以看出content此时宽度为574px,对比上一步增加了40px,左边缘向右移动&lt;/p&gt;
&lt;p&gt;此时test的border已经突破了父元素的border&lt;/p&gt;
&lt;h3 id=&#34;-marginleft-50px1&#34;&gt;第六步 设定margin-left: -50px;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/margin-50.png&#34; alt=&#34;marign-50&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示,可以看出content此时宽度为574px,对比上一步增加了40px,左边缘向右移动&lt;/p&gt;
&lt;h3 id=&#34;marginleftcontentmarginleftcontent&#34;&gt;由此我们可以得出一个结论:margin-left变大，content的宽度变小，理解为挤扁了，margin-left变小，content的宽度变大，理解为外扩了&lt;/h3&gt;
&lt;h2 id=&#34;margin1&#34;&gt;负margin在布局中的应用&lt;/h2&gt;
&lt;h3 id=&#34;httpjsjirengucomnijuf1edithtmlcssoutput&#34;&gt;不变的法则,举个&lt;a href=&#34;http://js.jirengu.com/nijuf/1/edit?html,css,output&#34;&gt;栗子&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;以下是代码:&lt;/p&gt;
&lt;h3 id=&#34;html1&#34;&gt;HTML代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;负margin的应用&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;div&amp;gt;1&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;2&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;3&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;4&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;css1&#34;&gt;CSS代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;*{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
.container{
  margin: 50px;
  width: 600px;
  outline: 2px solid green;
  display: flex;
}
.container&amp;gt;div{
  width: 120px;
  height: 120px;
  margin-right: 40px;
  border: 2px solid grey;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/flex-demo.png&#34; alt=&#34;flex-demo&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是在四栏布局中经常遇到的问题,设置margin-right时,最右侧会有间隙&lt;/p&gt;
&lt;p&gt;此时就需要使用负margin解决,把代码改成如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/flex-code.png&#34; alt=&#34;flex-code&#34;&gt;&lt;/p&gt;
&lt;p&gt;此是上面问题已完美解决,四栏布局完成,那增加的负margin究竟起了什么作用呢?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/margin%E4%BD%9C%E7%94%A8div.png&#34; alt=&#34;margin作用div&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示,content的边框已经超出了container的边框&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/margin%E4%BD%9C%E7%94%A8.x.png&#34; alt=&#34;margin作用.x&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示,.x的宽度原本应该和container一样为600px,受负margin的影响,由上文可知margin-left变小，content的宽度变大.所以宽度变为640px&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/margin%E4%BD%9C%E7%94%A8.con.png&#34; alt=&#34;margin作用.con&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示,container的宽度依然为600px,此时由于display的默认样式hidden,所有.x突出的部分自然被隐藏了,四栏布局就实现了&lt;/p&gt;
&lt;p&gt;这就是负margin在四栏布局中的作用&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>HTML常用标签</title>
      <link>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Thu, 12 Dec 2019 16:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      
        <description>&lt;h2 id=&#34;a-&#34;&gt;a 标签的用法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;a-href&#34;&gt;a 的href取值&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;heading&#34;&gt;网址&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;https  &lt;code&gt;&amp;lt;a href=&amp;quot;https//google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;http  &lt;code&gt;&amp;lt;a href=&amp;quot;http//google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;//  &lt;code&gt;&amp;lt;a href=&amp;quot;//google.com&amp;quot;&amp;gt;谷歌&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以上三种形式均可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;heading1&#34;&gt;路径&lt;/h4&gt;
&lt;p&gt;相对路径和绝对路径都可以.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;heading2&#34;&gt;伪协议&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;javascript,可以引入JS代码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;javascript:alert(1);&amp;quot;&amp;gt;javascript&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mailto,点击后跳转到发邮件页面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;mailto:943514589@qq.com&amp;quot;&amp;gt;send mail to&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以下是mailto的详细用法&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/mailto.png&#34; alt=&#34;mailto&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tel,手机点击后跳转到呼叫页面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;tel:13311113322&amp;quot;&amp;gt;phone call&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;id&#34;&gt;id&lt;/h4&gt;
&lt;p&gt;id,可以跳转到页面内id所标记的元素位置&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;#xxx&amp;quot;&amp;gt;查看ID为xxx的项目&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;target&#34;&gt;target的取值&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;heading3&#34;&gt;内置命名&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取值为_blank,a标签的链接在新窗口打开&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取值为_top,a标签的链接在最顶层的窗口打开&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取值为_parent,a标签的链接在其上一层的窗口打开&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取值为_self,a标签的链接在当前窗口打开&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;heading4&#34;&gt;程序员命名&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;取值为window的name,a标签的链接会在对应名称的窗口打开&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;取值为iframe的name,a标签的链接会在对应名称的内嵌窗口打开&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;h4 id=&#34;download&#34;&gt;download&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;下载a标签的目标链接&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;img-&#34;&gt;img 标签的用法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;heading5&#34;&gt;作用&lt;/h3&gt;
&lt;p&gt;img的作用是发出get请求,展示一张照片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;heading6&#34;&gt;属性&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;alt 当图片请求失败是,显示alt内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;height 设定图片高度,单位默认px&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;width 设定图片宽度,单位默认px&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;src 填写资源地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;heading7&#34;&gt;事件&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;onload,图片加载成功时触发事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;onerror,图片加载失败时触发事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;heading8&#34;&gt;响应式&lt;/h3&gt;
&lt;p&gt;响应式页面,可以适合不同屏幕及手机端查看,需要加上max-width: 100%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;heading9&#34;&gt;可替换元素&lt;/h3&gt;
&lt;p&gt;可替换元素（replaced element）的展现效果不是由 CSS 来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;table-&#34;&gt;table 标签的用法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;table&#34;&gt;table的基本结构&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
    &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;英语&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;翻译&amp;lt;/th&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;hyper&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;超级&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/tbody&amp;gt;
    &amp;lt;tfoot&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;nothing&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;nothing&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/tfoot&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;thead 表头 ；tbody 表身 ；tfoot 表尾；
包含在以上三个属性中的有tr 一行、th会加粗、td不会加粗。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;table1&#34;&gt;table的相关样式&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h4 id=&#34;tablelayout&#34;&gt;table-layout&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;table-layout取值为fixed时,每列宽度等宽&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;table-layout取值为auto时,每列宽度根据其内容宽度设定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;bordercollapse&#34;&gt;border-collapse,此属性可以消除表格边界之间的距离&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;borderspacing&#34;&gt;border-spacing,此属性可以修改表格边界之间的距离&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;heading10&#34;&gt;最后写一点想法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;html&#34;&gt;html标签十分之多,但并不是所用标签都能经常用到,所以不需要每个标签逐个学习,只需要先把常用的学习了,剩下的在工作中遇到再学习&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3 id=&#34;htmlhtml&#34;&gt;html标签的默认样式,大部分已经过时(不符合现在的审美),建议在编写网站时先把html标签的默认样式取消掉&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>HTML入门笔记1</title>
      <link>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Wed, 11 Dec 2019 16:23:26 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</guid>
      
        <description>&lt;h1 id=&#34;html-&#34;&gt;Ⅰ.HTML 是谁发明的？&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/Sir_Tim_Berners-Lee.jpg&#34; alt=&#34;李爵士&#34;&gt;&lt;/p&gt;
&lt;p&gt;HTML 诞生于蒂姆·伯纳斯-李爵士的一篇文章&lt;a href=&#34;https://html.com/tags/&#34;&gt;HTML Tags&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;html&#34;&gt;Ⅱ.什么是HTML？&lt;/h1&gt;
&lt;p&gt;HTML 是网页使用的语言，定义了网页的结构和内容。浏览器访问网站，其实就是从服务器下载 HTML 代码，然后渲染出网页。HTML 的全名是“超文本标记语言”（HyperText Markup Language）&lt;/p&gt;
&lt;h1 id=&#34;html-1&#34;&gt;Ⅲ.HTML 起手应该写什么&lt;/h1&gt;
&lt;p&gt;HTML起手应该包含以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提示：html文件用VScode打开后，输入!之后按tab键，上述代码将会自动生成，方便快捷。&lt;/p&gt;
&lt;h1 id=&#34;heading&#34;&gt;Ⅳ.网页的基本标签有哪些&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;doctype&#34;&gt;&lt;code&gt;&amp;lt;!doctype&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网页的第一个标签通常是&lt;code&gt;&amp;lt;!doctype&amp;gt;&lt;/code&gt;，表示文档类型，告诉浏览器如何解析网页。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;html1&#34;&gt;&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;标签是网页的顶层容器，也称为根元素（root element），其他元素都是它的子元素。一个网页只能有一个&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;标签。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;head&#34;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标签是一个容器标签，用于放置网页的元信息。它的内容不会出现在网页上，而是为网页渲染做准备。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;meta&#34;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签用于设置或说明网页的元数据，必须放在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;里面。一个&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;标签就是一项元数据，网页可以有多个&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;标签用于指定网页的标题，会显示在浏览器窗口的标题栏。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;body&#34;&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签是一个容器标签，用于放置网页的主体内容。浏览器显示的页面内容，都是放置在它的内部。它是&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;的第二个子元素，紧跟在&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;后面。&lt;/p&gt;
&lt;h1 id=&#34;heading1&#34;&gt;Ⅴ.常用的表章节的标签有哪些&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;h1h6&#34;&gt;&lt;code&gt;&amp;lt;h1&amp;gt;~&amp;lt;h6&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTML 提供了6个标签，用来表示文章的标题。按照标题的等级，一共分成六级。&lt;code&gt;h1`~&lt;/code&gt;h6`分别为一级标题、二级标题、三级标题、四级标题、五级标题、六级标题。默认情况下，浏览器会粗体显示标题。h1的字号比h2大，h2比h3大，以此类推。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/h1~h6.png&#34; alt=&#34;h1~h6&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;section&#34;&gt;&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;标签表示一个含有主题的独立部分，通常用在文档里面表示一个章节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;article&#34;&gt;&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;标签表示页面里面一段完整的内容，即使页面的其他部分不存在，也具有独立使用的意义，通常用来表示一篇文章或者一个论坛帖子。它可以有自己的标题（&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;到&lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;aside&#34;&gt;&lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;标签用来放置与网页或文章主要内容间接相关的部分。网页级别的&lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;，可以用来放置侧边栏，但不一定就在页面的侧边；文章级别的&lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;，可以用来放置评论或注释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;main&#34;&gt;&lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt;标签表示页面的主体内容，一个页面只能有一个&lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;heading2&#34;&gt;Ⅵ.全局属性有哪些&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;class&#34;&gt;class&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;class属性用来对网页元素进行分类。如果不同元素的class属性值相同，就表示它们是一类的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;contenteditable&#34;&gt;contenteditable&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTML 网页的内容默认是用户不能编辑，contenteditable属性允许用户修改内容。它有两个可能的值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;true或空字符串：内容可以编辑&lt;/li&gt;
&lt;li&gt;false：不可以编辑&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;hidden&#34;&gt;hidden&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;hidden是一个布尔属性，表示当前的网页元素不再跟页面相关，因此浏览器不会渲染这个元素，所以就不会在网页中看到它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;id&#34;&gt;id&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;id属性是元素在网页内的唯一标识符。比如，网页可能包含多个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签，id属性可以指定每个&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签的唯一标识符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;style&#34;&gt;style&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;style属性用来指定当前元素的 CSS 样式。具体的设置，请看 CSS 教程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;tabindex&#34;&gt;tabindex&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;tabindex属性的值是一个整数，表示用户按下 Tab 键的时候，网页焦点转移的顺序。不同的属性值有不同的含义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;负整数：该元素可以获得焦点（比如使用 JavaScript 的focus()方法），但不参与 Tab 键对网页元素的遍历。这个值通常是-1。&lt;/li&gt;
&lt;li&gt;0：该元素参与 Tab 键的遍历，顺序由浏览器指定，通常是按照其在网页里面出现的位置。&lt;/li&gt;
&lt;li&gt;正整数：网页元素按照从小到大的顺序（1、2、3、……），参与 Tab 键的遍历。如果多个元素的tabindex属性相同，则按照在网页源码里面出现的顺序遍历。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;title&#34;&gt;title&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;title属性用来为元素添加附加说明。大多数浏览器中，鼠标悬浮在元素上面时，会将title属性值作为浮动提示，显示出来。&lt;/p&gt;
&lt;h1 id=&#34;heading3&#34;&gt;Ⅶ.常用的内容标签有哪些&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;a&#34;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链接通过&lt;!-- raw HTML omitted --&gt;标签表示，用户点击后，浏览器会跳转到指定的网址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;strong&#34;&gt;&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;style属性用来指定当前元素的 CSS 样式。具体的设置，请看 CSS 教程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;em&#34;&gt;em&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;是一个行内标签，表示强调（emphasize），浏览器会以斜体显示它包含的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;code&#34;&gt;&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;可以用于包裹代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;pre&#34;&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;是一个块级元素，表示保留原来的格式（preformatted），即浏览器会保留该标签内部原始的换行和空格。浏览器默认以等宽字体显示标签内容。&lt;/p&gt;
&lt;h1 id=&#34;heading4&#34;&gt;Ⅷ.最后介绍两个在线编程网站&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://js.jirengu.com/?html,output&#34;&gt;饥人谷Jsbin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点速度快，但是只能编写单个文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://codesandbox.io/&#34;&gt;codesanbox&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;速度较慢，但是有在线文件夹，可上传图片等等&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>如何使用Hugo搭建个人博客</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 10 Dec 2019 15:24:33 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>&lt;h1 id=&#34;hugo&#34;&gt;Hugo是什么？&lt;/h1&gt;
&lt;p&gt;Hugo是一个用Go语言编写的静态网站生成器，Hugo一般只需要几秒钟就能生成一个网站（每页少于1毫秒），被称为”世界上最快的网站构建框架“，是最热门的静态网站生成器之一，被广泛采用。&lt;/p&gt;
&lt;h1 id=&#34;hugo1&#34;&gt;如何使用Hugo搭建个人博客&lt;/h1&gt;
&lt;h2 id=&#34;step1hugo&#34;&gt;Step1：安装Hugo&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下载&lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;Hugo安装包&lt;/a&gt;
&lt;img src=&#34;http://localhost:1313/images/hugo%E5%AE%89%E8%A3%85%E5%8C%85.png&#34; alt=&#34;下在windos版本的安装包&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载到安装包，解压后把hugo.exe.放到x:\xxx\hugo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加环境变量：点击计算机图标-右键-属性-高级系统设置-系统变量-path&lt;img src=&#34;http://localhost:1313/images/hugo-path.png&#34; alt=&#34;环境变量&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;4.重启终端，运行hugo version。安装成功就能查看到版本号
&lt;img src=&#34;http://localhost:1313/images/hugo_version.png&#34; alt=&#34;hugo_version&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;step2-hugo&#34;&gt;Step2: 创建一个新的Hugo网页&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;进入&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo官网&lt;/a&gt;，点击Quick Start。&lt;/li&gt;
&lt;li&gt;Step1操作前面已完成，直接操作Step2&lt;/li&gt;
&lt;li&gt;复制Step2的代码，在cmder上运行。注意这里要把”quickstart“改成“github用户名.github.io-creater!”(这样操作的好处是，上传到GitHub上后方便标识。)
&lt;img src=&#34;http://localhost:1313/images/hugo-step2.png&#34; alt=&#34;hugo-step2&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;step3-&#34;&gt;Step3: 下载一个主题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;依次复制Step3的代码在cmder上运行
&lt;img src=&#34;http://localhost:1313/images/hugo-step3.png&#34; alt=&#34;hugo-step3&#34;&gt;&lt;/li&gt;
&lt;li&gt;由于主题是国外资源，国内下载很慢，建议挂VPN下载&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;step4-&#34;&gt;Step4: 新建一篇文章&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;复制Step4的代码在cmder上运行
&lt;img src=&#34;http://localhost:1313/images/hugo-step4.png&#34; alt=&#34;hugo-step4&#34;&gt;&lt;/li&gt;
&lt;li&gt;打开新建的markdown文件&lt;/li&gt;
&lt;li&gt;将draft: true 改为false(draft为草稿意思，改为false后文章才会显示在blog上)
&lt;img src=&#34;http://localhost:1313/images/hugo-step4-2.png&#34; alt=&#34;hugo-step4-2&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;step5-hugo&#34;&gt;Step5: 开启Hugo服务器&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;复制Step5的代码在cmder上运行
&lt;img src=&#34;http://localhost:1313/images/hugo-step5.png&#34; alt=&#34;hugo-step5&#34;&gt;&lt;/li&gt;
&lt;li&gt;运行后不要关闭服务器(关闭后本地访问会失败)&lt;/li&gt;
&lt;li&gt;在浏览器中访问http://localhost:1313/或者127.0.0.1:1313&lt;/li&gt;
&lt;li&gt;此时将会看到你新建的blog&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;step6-&#34;&gt;Step6 自定义主题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;打开hugo网站根目录的config.toml&lt;/li&gt;
&lt;li&gt;可自定义一下代码，包括：语言、博客名
&lt;img src=&#34;http://localhost:1313/images/hugo-step6.png&#34; alt=&#34;hugo-step6&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;step7-&#34;&gt;Step7 简历静态网站&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;复制Step7的代码在cmder上运行
&lt;img src=&#34;http://localhost:1313/images/hugo-step7.png&#34; alt=&#34;hugo-step7&#34;&gt;&lt;/li&gt;
&lt;li&gt;运行后将会得到一个public的目录&lt;/li&gt;
&lt;li&gt;在hugo的更目录中创建名为“.gitignore”的文件&lt;/li&gt;
&lt;li&gt;编辑“.gitignore”,写入/public/(由于hugo根目录和public需要分别上传到GitHub，此操作可以防止子仓库的问题出现)&lt;/li&gt;
&lt;li&gt;在GitHub上新建一个仓库，命名为github用户名.github.io&lt;/li&gt;
&lt;li&gt;把public目录上传到新建的仓库中&lt;/li&gt;
&lt;li&gt;在你的git仓库里面Settings的GitHub Pages下你可以看到http://你的用户名.http://github.io的链接。&lt;/li&gt;
&lt;li&gt;打开此链接，就能看到你的Hugo已经被挂到网上了&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;heading&#34;&gt;大功告成&lt;/h1&gt;
&lt;h2 id=&#34;heading1&#34;&gt;最后你还可这样做&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在你的GitHub上新建一个仓库，命名为github用户名.github.io-creator&lt;/li&gt;
&lt;li&gt;将Hugo根目录的文件上传到此仓库(注意：Hugo根目录上存储着原代码，Hugo根目录丢失，就无法写博客了)&lt;/li&gt;
&lt;/ol&gt;
</description>
      
    </item>
    
    <item>
      <title>开博大吉</title>
      <link>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</link>
      <pubDate>Mon, 09 Dec 2019 15:29:33 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%A4%A7%E5%90%89/</guid>
      
        <description>&lt;h1 id=&#34;heading&#34;&gt;大家好&lt;/h1&gt;
&lt;p&gt;我的博客开通了，希望我能写出好文章给大家看&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
